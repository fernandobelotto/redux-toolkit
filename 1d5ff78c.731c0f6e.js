/*! For license information please see 1d5ff78c.731c0f6e.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{68:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return l}));var a=n(2),s=n(6),o=(n(90),n(89)),r={id:"advanced-tutorial",title:"Advanced Tutorial",sidebar_label:"Advanced Tutorial",hide_title:!0},i={unversionedId:"tutorials/advanced-tutorial",id:"tutorials/advanced-tutorial",isDocsHomePage:!1,title:"Advanced Tutorial",description:"Tutorial avan\xe7ado: Redux Toolkit na pr\xe1tica",source:"@site/..\\docs\\tutorials\\advanced-tutorial.md",slug:"/tutorials/advanced-tutorial",permalink:"/redux-toolkit/tutorials/advanced-tutorial",version:"current",sidebar_label:"Advanced Tutorial",sidebar:"docs",previous:{title:"Tutorial intermedi\xe1rio",permalink:"/redux-toolkit/tutorials/intermediate-tutorial"},next:{title:"Guia de uso",permalink:"/redux-toolkit/usage/usage-guide"}},c=[{value:"Revisando o exemplo de aplicativo inicial",id:"revisando-o-exemplo-de-aplicativo-inicial",children:[{value:"React Codebase Source Overview",id:"react-codebase-source-overview",children:[]}]},{value:"Setting Up the Redux Store",id:"setting-up-the-redux-store",children:[]},{value:"Converting the Main App Display",id:"converting-the-main-app-display",children:[{value:"Evaluating the Existing App State",id:"evaluating-the-existing-app-state",children:[]},{value:"Creating the Initial State Slices",id:"creating-the-initial-state-slices",children:[]},{value:"Converting the Issues Display",id:"converting-the-issues-display",children:[]}]},{value:"Converting the Issues List Page",id:"converting-the-issues-list-page",children:[{value:"Reviewing the Issues List Component",id:"reviewing-the-issues-list-component",children:[]},{value:"Thinking in Thunks",id:"thinking-in-thunks",children:[]},{value:"Logic for Fetching Github Repo Details",id:"logic-for-fetching-github-repo-details",children:[]},{value:"Fetching Repo Details in the Issues List",id:"fetching-repo-details-in-the-issues-list",children:[]},{value:"Logic for Fetching Issues for a Repo",id:"logic-for-fetching-issues-for-a-repo",children:[]},{value:"Fetching Issues in the Issues List",id:"fetching-issues-in-the-issues-list",children:[]}]},{value:"Converting the Issue Details Page",id:"converting-the-issue-details-page",children:[{value:"Reviewing the Issue Details Component",id:"reviewing-the-issue-details-component",children:[]},{value:"Fetching the Current Issue",id:"fetching-the-current-issue",children:[]},{value:"Logic for Fetching Comments",id:"logic-for-fetching-comments",children:[]},{value:"Fetching the Issue Comments",id:"fetching-the-issue-comments",children:[]}]},{value:"Summary",id:"summary",children:[]}],u={rightToc:c};function l(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"tutorial-avan\xe7ado-redux-toolkit-na-pr\xe1tica"},"Tutorial avan\xe7ado: Redux Toolkit na pr\xe1tica"),Object(o.b)("p",null,"No ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/redux-toolkit/tutorials/intermediate-tutorial"}),"Tutorial intermedi\xe1rio"),', voc\xea viu como usar o Redux Toolkit em um aplicativo React b\xe1sico t\xedpico, bem como converter algum c\xf3digo Redux simples existente para usar RTK. Voc\xea tamb\xe9m viu como escrever atualiza\xe7\xf5es imut\xe1veis \u200b\u200b"mutativas" em fun\xe7\xf5es redutoras e como escrever um "retorno de chamada de prepara\xe7\xe3o" para gerar uma carga \xfatil de a\xe7\xe3o.'),Object(o.b)("p",null,'Neste tutorial, voc\xea ver\xe1 como usar o Redux Toolkit como parte de um aplicativo maior do "mundo real" que \xe9 maior do que um exemplo de lista de tarefas. Este tutorial mostrar\xe1 v\xe1rios conceitos:'),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},'Como converter um aplicativo "simples do React" para usar o Redux'),Object(o.b)("li",{parentName:"ul"},"Como a l\xf3gica ass\xedncrona, como a busca de dados, se encaixa no RTK"),Object(o.b)("li",{parentName:"ul"},"Como usar RTK com TypeScript")),Object(o.b)("p",null,"No processo, veremos alguns exemplos de t\xe9cnicas do TypeScript que voc\xea pode usar para melhorar seu c\xf3digo e veremos como usar as novas ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://react-redux.js.org/api/hooks"}),"APIs de hook do React-Redux")," como uma alternativa \xe0 ","[a tradicional API ",Object(o.b)("inlineCode",{parentName:"p"},"connect"),"]"," (",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://react-redux.js.org/api/connect"}),"https://react-redux.js.org/api/connect"),")."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},Object(o.b)("strong",{parentName:"p"},"Nota"),": Este n\xe3o \xe9 um tutorial completo sobre como usar o TypeScript em geral ou com Redux especificamente, e os exemplos mostrados aqui n\xe3o tentam atingir 100% de seguran\xe7a de tipo completa. Para obter mais informa\xe7\xf5es, consulte os recursos da comunidade, como o ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/typescript-cheatsheets/react"}),"React TypeScript Cheatsheet")," e o ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/piotrwitek/react-redux-typescript-guide"}),"React / Redux TypeScript Guide"),"."),Object(o.b)("p",{parentName:"blockquote"},"Al\xe9m disso, este tutorial n\xe3o significa que voc\xea ",Object(o.b)("em",{parentName:"p"},"deve")," converter a l\xf3gica do aplicativo React completamente para Redux. ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://redux.js.org/faq/organizing-state#do-i-have-to-put-all-my-state-into-redux-should-i-ever-use-reats-setstate"}),"Cabe a voc\xea decidir qual estado deve viver nos componentes React e o que deve estar no Redux"),". Este \xe9 apenas um exemplo de como voc\xea ",Object(o.b)("em",{parentName:"p"},"pode")," converter a l\xf3gica para usar o Redux, se desejar.")),Object(o.b)("p",null,"O c\xf3digo-fonte completo para o aplicativo convertido deste tutorial est\xe1 dispon\xedvel em ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/reduxjs/rtk-github-issues-example"}),"github.com/reduxjs/rtk-github-issues-example"),". Percorreremos o processo de convers\xe3o, conforme mostrado no hist\xf3rico deste repo. Links para commits individuais significativos ser\xe3o destacados em blocos de cita\xe7\xf5es, como este:"),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},"Commit message here"))),Object(o.b)("h2",{id:"revisando-o-exemplo-de-aplicativo-inicial"},"Revisando o exemplo de aplicativo inicial"),Object(o.b)("p",null,"The example application for this tutorial is a Github Issues viewer app. It allows the user to enter the names of a Github org and repository, fetch the current list of open issues, page through the issues list, and view the contents and comments of a specific issue."),Object(o.b)("p",null,"The starting commit for this application is a plain React implementation that uses function components with hooks for state and side effects like data fetching. The code is already written in TypeScript, and the styling is done via CSS Modules."),Object(o.b)("p",null,"Let's start by viewing the original plain React app in action:"),Object(o.b)("iframe",{src:"https://codesandbox.io/embed/rsk-github-issues-example-8jf6d?fontsize=14&hidenavigation=1&theme=dark&view=preview",style:{width:"100%",height:"500px",border:0,borderRadius:"4px",overflow:"hidden"},title:"rtk-github-issues-example-01-plain-react",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),Object(o.b)("h3",{id:"react-codebase-source-overview"},"React Codebase Source Overview"),Object(o.b)("p",null,'The codebase is already laid out in a "feature folder" structure, The main pieces are:'),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"/api"),": fetching functions and TS types for the Github Issues API"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"/app"),": main ",Object(o.b)("inlineCode",{parentName:"li"},"<App>")," component"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"/components"),": components that are reused in multiple places"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"/features"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"/issueDetails:")," components for the Issue Details page"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"/issuesList"),": components for the Issues List display"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"/repoSearch"),": components for the Repo Search form"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"/utils"),": various string utility functions")),Object(o.b)("h2",{id:"setting-up-the-redux-store"},"Setting Up the Redux Store"),Object(o.b)("p",null,"Since this app doesn't yet use Redux at all, the first step is to install Redux Toolkit and React-Redux. Since this is a TypeScript app, we'll also need to add ",Object(o.b)("inlineCode",{parentName:"p"},"@types/react-redux")," as well. Add those packages to the project via either Yarn or NPM."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Add_Redux_Toolkit_and_React-Redux_packages~1..reduxjs:Add_Redux_Toolkit_and_React-Redux_packages"}),"Add Redux Toolkit and React-Redux packages")))),Object(o.b)("p",null,"Next, we need to set up the usual pieces: a root reducer function, the Redux store, and the ",Object(o.b)("inlineCode",{parentName:"p"},"<Provider>")," to make that store available to our component tree."),Object(o.b)("p",null,'In the process, we\'re going to set up "Hot Module Replacement" for our app. That way, whenever we make a change to the reducer logic or the component tree, Create-React-App will rebuild the app and swap the changed code into our running app, without having to completely refresh the page.'),Object(o.b)("h4",{id:"creating-the-root-reducer"},"Creating the Root Reducer"),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Add_store_and_root_reducer_with_reducer_HMR~1..reduxjs:Add_store_and_root_reducer_with_reducer_HMR"}),"Add store and root reducer with reducer HMR")))),Object(o.b)("p",null,"First, we'll create the root reducer function. We don't have any slices yet, so it will just return an empty object."),Object(o.b)("p",null,"However, we're going to want to know what the TypeScript type is for that root state object, because we need to declare what the type of the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," variable is whenever our code needs to access the Redux store state (such as in ",Object(o.b)("inlineCode",{parentName:"p"},"mapState")," functions, ",Object(o.b)("inlineCode",{parentName:"p"},"useSelector")," selectors, and ",Object(o.b)("inlineCode",{parentName:"p"},"getState")," in thunks)."),Object(o.b)("p",null,"We could manually write a TS type with the correct types for each state slice, but we'd have to keep updating that type every time we make any change to the state structure in our slices. Fortunately, TS is usually pretty good at inferring types from the code we've already written. In this case, we can define a type that says \"this type is whatever gets returned from ",Object(o.b)("inlineCode",{parentName:"p"},"rootReducer"),"\", and TS will automatically figure out whatever that contains as the code is changed. If we export that type, other parts of the app can use it, and we know that it's up to date. All we have to do is use the built-in TS ",Object(o.b)("inlineCode",{parentName:"p"},"ReturnType"),' utility type, and feed in "the type of the ',Object(o.b)("inlineCode",{parentName:"p"},"rootReducer"),' function" as its generic argument.'),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"app/rootReducer.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { combineReducers } from '@reduxjs/toolkit'\n\nconst rootReducer = combineReducers({})\n\nexport type RootState = ReturnType<typeof rootReducer>\n\nexport default rootReducer\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},Object(o.b)("strong",{parentName:"p"},"Note:")," For other ways to infer the ",Object(o.b)("inlineCode",{parentName:"p"},"RootState"),", view the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"../usage/usage-with-typescript#getting-the-state-type"}),"Usage with TypeScript")," guide")),Object(o.b)("h4",{id:"store-setup-and-hmr"},"Store Setup and HMR"),Object(o.b)("p",null,"Next, we'll create the store instance, including hot-reloading the root reducer. By using the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://webpack.js.org/concepts/hot-module-replacement/"}),Object(o.b)("inlineCode",{parentName:"a"},"module.hot")," API for reloading"),", we can re-import the new version of the root reducer function whenever it's been recompiled, and tell the store to use the new version instead."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"app/store.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { configureStore } from '@reduxjs/toolkit'\n\nimport rootReducer from './rootReducer'\n\nconst store = configureStore({\n  reducer: rootReducer\n})\n\nif (process.env.NODE_ENV === 'development' && module.hot) {\n  module.hot.accept('./rootReducer', () => {\n    const newRootReducer = require('./rootReducer').default\n    store.replaceReducer(newRootReducer)\n  })\n}\n\nexport type AppDispatch = typeof store.dispatch\n\nexport default store\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"require('./rootReducer').default")," looks a bit odd. That's because we're mixing CommonJS synchronous import syntax with ES modules, so the \"default export\" is in a object field called ",Object(o.b)("inlineCode",{parentName:"p"},"default"),". We could probably also have used ",Object(o.b)("inlineCode",{parentName:"p"},"import()")," and handled the reducer replacement asynchronously as well."),Object(o.b)("h4",{id:"rendering-the-provider"},"Rendering the ",Object(o.b)("inlineCode",{parentName:"h4"},"Provider")),Object(o.b)("p",null,"Now that the store has been created, we can add it to the React component tree."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Render_Redux_Provider_with_app_HMR~1..reduxjs:Render_Redux_Provider_with_app_HMR"}),"Render Redux Provider with app HMR")))),Object(o.b)("p",null,"As with the root reducer, we can hot-reload the React component tree whenever a component file changes. The best way is to write a function that imports the ",Object(o.b)("inlineCode",{parentName:"p"},"<App>")," component and renders it, call that once on startup to show the React component tree as usual, and then reuse that function any time a component is changed."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"index.tsx")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux'\n\nimport store from './app/store'\n\nimport './index.css'\n\nconst render = () => {\n  const App = require('./app/App').default\n\n  ReactDOM.render(\n    <Provider store={store}>\n      <App />\n    </Provider>,\n    document.getElementById('root')\n  )\n}\n\nrender()\n\nif (process.env.NODE_ENV === 'development' && module.hot) {\n  module.hot.accept('./app/App', render)\n}\n")),Object(o.b)("h2",{id:"converting-the-main-app-display"},"Converting the Main App Display"),Object(o.b)("p",null,"With the main store setup done, we can now start converting the actual app logic to use Redux."),Object(o.b)("h3",{id:"evaluating-the-existing-app-state"},"Evaluating the Existing App State"),Object(o.b)("p",null,"Currently, the top-level <",Object(o.b)("inlineCode",{parentName:"p"},"App>")," component uses React ",Object(o.b)("inlineCode",{parentName:"p"},"useState")," hooks to store several pieces of info:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The selected Github org and repo"),Object(o.b)("li",{parentName:"ul"},"The current issues list page number"),Object(o.b)("li",{parentName:"ul"},"Whether we're viewing the issues list, or the details for a specific issue")),Object(o.b)("p",null,"Meanwhile, the ",Object(o.b)("inlineCode",{parentName:"p"},"<RepoSearchForm>")," component also uses state hooks to store the work-in-progress values for the controlled form inputs."),Object(o.b)("p",null,"The Redux FAQ has ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://redux.js.org/faq/organizing-state#do-i-have-to-put-all-my-state-into-redux-should-i-ever-use-reacts-setstate"}),"some rules of thumb on when it makes sense to put data into Redux"),". In this case, it's reasonable to extract the state values from ",Object(o.b)("inlineCode",{parentName:"p"},"<App>")," and put those into the Redux store. While there's only one component that uses them now, a larger app might have multiple components that care about those values. Since we've set up HMR, it would also be helpful to persist those values if we make future edits to the component tree."),Object(o.b)("p",null,"On the other hand, while we ",Object(o.b)("em",{parentName:"p"},"could")," put the WIP form values into the Redux store, there's no real benefit to doing so. Only the ",Object(o.b)("inlineCode",{parentName:"p"},"<RepoSearchForm>")," component cares about those values, and none of the other rules of thumb apply here. In general, ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://redux.js.org/faq/organizing-state#should-i-put-form-state-or-other-ui-state-in-my-store"}),"most form state probably shouldn't be kept in Redux"),". So, we'll leave that alone."),Object(o.b)("h3",{id:"creating-the-initial-state-slices"},"Creating the Initial State Slices"),Object(o.b)("p",null,"The first step is to look at the data that is currently being kept in ",Object(o.b)("inlineCode",{parentName:"p"},"<App>"),', and turn that into the types and initial state values for our "issues display" slice. From there, we can define reducers to update them appropriately.'),Object(o.b)("p",null,"Let's look at the source for the whole slice, and then break down what it's doing:"),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Add_initial_state_slice_for_UI_display~1..reduxjs:Add_initial_state_slice_for_UI_display"}),"Add initial state slice for UI display")))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"features/issuesDisplay/issuesDisplaySlice.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\ninterface CurrentDisplay {\n  displayType: 'issues' | 'comments'\n  issueId: number | null\n}\n\ninterface CurrentDisplayPayload {\n  displayType: 'issues' | 'comments'\n  issueId?: number\n}\n\ninterface CurrentRepo {\n  org: string\n  repo: string\n}\n\ntype CurrentDisplayState = {\n  page: number\n} & CurrentDisplay &\n  CurrentRepo\n\nlet initialState: CurrentDisplayState = {\n  org: 'rails',\n  repo: 'rails',\n  page: 1,\n  displayType: 'issues',\n  issueId: null\n}\n\nconst issuesDisplaySlice = createSlice({\n  name: 'issuesDisplay',\n  initialState,\n  reducers: {\n    displayRepo(state, action: PayloadAction<CurrentRepo>) {\n      const { org, repo } = action.payload\n      state.org = org\n      state.repo = repo\n    },\n    setCurrentPage(state, action: PayloadAction<number>) {\n      state.page = action.payload\n    },\n    setCurrentDisplayType(state, action: PayloadAction<CurrentDisplayPayload>) {\n      const { displayType, issueId = null } = action.payload\n      state.displayType = displayType\n      state.issueId = issueId\n    }\n  }\n})\n\nexport const {\n  displayRepo,\n  setCurrentDisplayType,\n  setCurrentPage\n} = issuesDisplaySlice.actions\n\nexport default issuesDisplaySlice.reducer\n")),Object(o.b)("h4",{id:"state-contents-type-declarations"},"State Contents Type Declarations"),Object(o.b)("p",null,"The org and repo values are simple strings, and the current issues page is just a number. We will use a union of string constants to indicate if we're showing the issues list or the details of a single issue, and if it's the details, we need to know the issue ID number."),Object(o.b)("p",null,"We can define types for a couple of those pieces by themselves for reuse in the action types later, and also combine them into a larger type for the entire state we plan to track."),Object(o.b)("p",null,"The \"current display\" part requires a bit of extra work, because the type listed for the state includes a page number, but the UI won't include one when it dispatches an action to switch to the issues list. So, we define a separate type for that action's contents."),Object(o.b)("h4",{id:"declaring-types-for-slice-state-and-actions"},"Declaring Types for Slice State and Actions"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"createSlice")," tries to infer types from two sources:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The state type is based on the type of the ",Object(o.b)("inlineCode",{parentName:"li"},"initialState")," field"),Object(o.b)("li",{parentName:"ul"},"Each reducer needs to declare the type of the action it expects to handle")),Object(o.b)("p",null,"The state type is used as the type for the ",Object(o.b)("inlineCode",{parentName:"p"},"state"),' parameter in each of the case reducers and the return type for the generated reducer function, and the action types are used for the corresponding generated action creators. (Alternately, if you define a "prepare callback" alongside a reducer, the prepare callback\'s arguments are used for the action creator too, and the return value from the callback must match the declared type for the action the reducer expects.)'),Object(o.b)("p",null,"The main type you will use when declaring action types in reducers is ",Object(o.b)("strong",{parentName:"p"},Object(o.b)("inlineCode",{parentName:"strong"},"PayloadAction<PayloadType>")),". ",Object(o.b)("inlineCode",{parentName:"p"},"createAction")," uses this type as its return value."),Object(o.b)("p",null,"Let's look at a specific reducer as an example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"setCurrentPage(state, action: PayloadAction<number>) {\n    state.page = action.payload\n},\n")),Object(o.b)("p",null,"We don't have to declare a type for ",Object(o.b)("inlineCode",{parentName:"p"},"state"),", because ",Object(o.b)("inlineCode",{parentName:"p"},"createSlice")," already knows that this should be the same type as our ",Object(o.b)("inlineCode",{parentName:"p"},"initialState"),": the ",Object(o.b)("inlineCode",{parentName:"p"},"CurrentDisplayState")," type."),Object(o.b)("p",null,"We declare that the action object is a ",Object(o.b)("inlineCode",{parentName:"p"},"PayloadAction"),", where ",Object(o.b)("inlineCode",{parentName:"p"},"action.payload")," is a ",Object(o.b)("inlineCode",{parentName:"p"},"number"),". Then, when we assign ",Object(o.b)("inlineCode",{parentName:"p"},"state.page = action.payload"),", TS knows that we're assigning a number to a number, and it works correctly. If we were to try calling ",Object(o.b)("inlineCode",{parentName:"p"},"issuesDisplaySlice.actions.setCurrentPage()"),", we would need to pass a number in as the argument, because that number will become the payload in the action."),Object(o.b)("p",null,"Similarly, for ",Object(o.b)("inlineCode",{parentName:"p"},"displayRepo(state, action: PayloadAction<CurrentRepo>)"),", TS knows that ",Object(o.b)("inlineCode",{parentName:"p"},"action.payload")," is an object with ",Object(o.b)("inlineCode",{parentName:"p"},"org")," and ",Object(o.b)("inlineCode",{parentName:"p"},"repo"),' string fields, and we can assign them to the state. (Remember that these "mutative" assignments are only safe and possible because ',Object(o.b)("inlineCode",{parentName:"p"},"createSlice")," uses Immer inside!)"),Object(o.b)("h4",{id:"using-the-slice-reducer"},"Using the Slice Reducer"),Object(o.b)("p",null,"As with other examples, we then need to import and add the issues display slice reducer to our root reducer:"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"app/rootReducer.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff"}),"import { combineReducers } from '@reduxjs/toolkit'\n\n+import issuesDisplayReducer from 'features/issuesDisplay/issuesDisplaySlice'\n\n-const rootReducer = combineReducers({})\n+const rootReducer = combineReducers({\n+ issuesDisplay: issuesDisplayReducer\n+})\n")),Object(o.b)("h3",{id:"converting-the-issues-display"},"Converting the Issues Display"),Object(o.b)("p",null,"Now that the issues display slice is hooked up to the store, we can update ",Object(o.b)("inlineCode",{parentName:"p"},"<App>")," to use that instead of its internal component state."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Convert_main_issues_display_control_to_Redux~1..reduxjs:Convert_main_issues_display_control_to_Redux"}),"Convert main issues display control to Redux")))),Object(o.b)("p",null,"We need to make three groups of changes to the ",Object(o.b)("inlineCode",{parentName:"p"},"App")," component:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The ",Object(o.b)("inlineCode",{parentName:"li"},"useState")," declarations need to be removed"),Object(o.b)("li",{parentName:"ul"},"The corresponding state values need to be read from the Redux store"),Object(o.b)("li",{parentName:"ul"},"Redux actions need to be dispatched as the user interacts with the component")),Object(o.b)("p",null,"Traditionally, the last two aspects would be handled via the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://react-redux.js.org/api/connect"}),"React-Redux ",Object(o.b)("inlineCode",{parentName:"a"},"connect")," API"),". We'd write a ",Object(o.b)("inlineCode",{parentName:"p"},"mapState")," function to retrieve the data and a ",Object(o.b)("inlineCode",{parentName:"p"},"mapDispatch")," function to hold the action creators, pass those to ",Object(o.b)("inlineCode",{parentName:"p"},"connect"),", get everything as props, and then call ",Object(o.b)("inlineCode",{parentName:"p"},"this.props.setCurrentPage()")," to dispatch that action type."),Object(o.b)("p",null,"However, ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://react-redux.js.org/api/hooks"}),"React-Redux now has a hooks API"),", which allows us to interact with the store more directly. ",Object(o.b)("inlineCode",{parentName:"p"},"useSelector")," lets us read data from the store and subscribe to updates, and ",Object(o.b)("inlineCode",{parentName:"p"},"useDispatch")," gives us a reference to the store's ",Object(o.b)("inlineCode",{parentName:"p"},"dispatch")," method. We'll use those throughout the rest of this tutorial."),Object(o.b)("p",null,"First, we'll import the necessary functions, plus the ",Object(o.b)("inlineCode",{parentName:"p"},"RootState")," type we declared earlier, and remove the hardcoded default org and repo strings."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"app/App.tsx")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff"}),"import React, { useState } from 'react'\n+import { useSelector, useDispatch } from 'react-redux'\n\n+import { RootState } from './rootReducer'\n\nimport { RepoSearchForm } from 'features/repoSearch/RepoSearchForm'\nimport { IssuesListPage } from 'features/issuesList/IssuesListPage'\nimport { IssueDetailsPage } from 'features/issueDetails/IssueDetailsPage'\n\n-const ORG = 'rails'\n-const REPO = 'rails'\n+import {\n+  displayRepo,\n+  setCurrentDisplayType,\n+  setCurrentPage\n+} from 'features/issuesDisplay/issuesDisplaySlice'\n\nimport './App.css'\n")),Object(o.b)("p",null,"Next, at the top of ",Object(o.b)("inlineCode",{parentName:"p"},"App"),", we'll remove the old ",Object(o.b)("inlineCode",{parentName:"p"},"useState")," hooks, and replace them with a call to ",Object(o.b)("inlineCode",{parentName:"p"},"useDispatch")," and ",Object(o.b)("inlineCode",{parentName:"p"},"useSelector"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff"}),"const App: React.FC = () => {\n- const [org, setOrg] = useState(ORG)\n- const [repo, setRepo] = useState(REPO)\n- const [page, setPage] = useState(1)\n- const [currentDisplay, setCurrentDisplay] = useState<CurrentDisplay>({\n-   type: 'issues'\n- })\n+ const dispatch = useDispatch()\n\n+ const { org, repo, displayType, page, issueId } = useSelector(\n+   (state: RootState) => state.issuesDisplay\n+ )\n")),Object(o.b)("p",null,'We pass a "selector" function into ',Object(o.b)("inlineCode",{parentName:"p"},"useSelector"),", which is just a function that accepts our Redux store state as its parameter and returns some result. We declare that the type of the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," argument is the ",Object(o.b)("inlineCode",{parentName:"p"},"RootState")," type we defined over in the root reducer, so that TS knows what fields are inside ",Object(o.b)("inlineCode",{parentName:"p"},"state"),". We can retrieve the ",Object(o.b)("inlineCode",{parentName:"p"},"state.issuesDisplay")," slice as one piece, and destructure the result object into multiple variables inside the component."),Object(o.b)("p",null,"We now have mostly the same data variables inside the component as we did before - they're just coming from the Redux store instead of ",Object(o.b)("inlineCode",{parentName:"p"},"useState")," hooks."),Object(o.b)("p",null,"The last step is to dispatch Redux actions whenever the user does something, instead of calling the ",Object(o.b)("inlineCode",{parentName:"p"},"useState")," setters:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff"}),"  const setOrgAndRepo = (org: string, repo: string) => {\n-   setOrg(org)\n-   setRepo(repo)\n+   dispatch(displayRepo({ org, repo }))\n  }\n\n  const setJumpToPage = (page: number) => {\n-   setPage(page)\n+   dispatch(setCurrentPage(page))\n  }\n\n  const showIssuesList = () => {\n-   setCurrentDisplay({ type: 'issues' })\n+   dispatch(setCurrentDisplayType({ displayType: 'issues' }))\n  }\n\n  const showIssueComments = (issueId: number) => {\n-   setCurrentDisplay({ type: 'comments', issueId })\n+   dispatch(setCurrentDisplayType({ displayType: 'comments', issueId }))\n  }\n")),Object(o.b)("p",null,"Unlike typical ",Object(o.b)("inlineCode",{parentName:"p"},"connect")," + ",Object(o.b)("inlineCode",{parentName:"p"},"mapDispatch")," usage, here we call ",Object(o.b)("inlineCode",{parentName:"p"},"dispatch()")," directly, and do so by calling an action creator with the correct ",Object(o.b)("inlineCode",{parentName:"p"},"payload")," value and passing the resulting action to ",Object(o.b)("inlineCode",{parentName:"p"},"dispatch"),"."),Object(o.b)("p",null,"Let's see if this works!"),Object(o.b)("iframe",{src:"https://codesandbox.io/embed/rtk-github-issues-example-02-issues-display-tdx2w?fontsize=14&hidenavigation=1&module=%2Fsrc%2Fapp%2FApp.tsx&theme=dark&view=preview",style:{width:"100%",height:"500px",border:0,borderRadius:"4px",overflow:"hidden"},title:"rtk-github-issues-example-02-issues-display",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),Object(o.b)("p",null,"If you're thinking \"hey, this looks and behaves exactly like the previous example\"... then that's great! That means we've correctly converted the first bit of logic to Redux so far. If you want to confirm that there's Redux logic running, try clicking the \"Open in New Window\" button and inspect the store in the Redux DevTools Extension."),Object(o.b)("h2",{id:"converting-the-issues-list-page"},"Converting the Issues List Page"),Object(o.b)("p",null,"Our next task is to convert the ",Object(o.b)("inlineCode",{parentName:"p"},"<IssuesListPage>")," component to fetch and store issues via Redux. Currently, ",Object(o.b)("inlineCode",{parentName:"p"},"<IssuesListPage>")," is storing all data in ",Object(o.b)("inlineCode",{parentName:"p"},"useState")," hooks, including the fetched issues. It fetches the issues by making an AJAX call in a ",Object(o.b)("inlineCode",{parentName:"p"},"useEffect")," hook."),Object(o.b)("p",null,"As mentioned at the start, there's nothing actually wrong with this! Having React components fetch and store their own data is totally fine. But, for the purposes of this tutorial, we want to see how the Redux conversion process looks."),Object(o.b)("h3",{id:"reviewing-the-issues-list-component"},"Reviewing the Issues List Component"),Object(o.b)("p",null,"Here's the initial chunk of ",Object(o.b)("inlineCode",{parentName:"p"},"<IssuesListPage>"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"export const IssuesListPage = ({\n  org,\n  repo,\n  page = 1,\n  setJumpToPage,\n  showIssueComments\n}: ILProps) => {\n  const [issuesResult, setIssues] = useState<IssuesResult>({\n    pageLinks: null,\n    pageCount: 1,\n    issues: []\n  })\n  const [numIssues, setNumIssues] = useState<number>(-1)\n  const [isLoading, setIsLoading] = useState<boolean>(false)\n  const [issuesError, setIssuesError] = useState<Error | null>(null)\n\n  const { issues, pageCount } = issuesResult\n\n  useEffect(() => {\n    async function fetchEverything() {\n      async function fetchIssues() {\n        const issuesResult = await getIssues(org, repo, page)\n        setIssues(issuesResult)\n      }\n\n      async function fetchIssueCount() {\n        const repoDetails = await getRepoDetails(org, repo)\n        setNumIssues(repoDetails.open_issues_count)\n      }\n\n      try {\n        await Promise.all([fetchIssues(), fetchIssueCount()])\n        setIssuesError(null)\n      } catch (err) {\n        console.error(err)\n        setIssuesError(err)\n      } finally {\n        setIsLoading(false)\n      }\n    }\n\n    setIsLoading(true)\n\n    fetchEverything()\n  }, [org, repo, page])\n\n  // omit rendering\n}\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"useEffect")," callback defines an outer ",Object(o.b)("inlineCode",{parentName:"p"},"async function fetchEverything()")," and calls it immediately. This is because we can't declare the ",Object(o.b)("inlineCode",{parentName:"p"},"useEffect")," callback itself as async. React expects that the return value from a ",Object(o.b)("inlineCode",{parentName:"p"},"useEffect")," callback will be a cleanup function. Since all async functions return a ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," automatically, React would see that ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," instead, and that would prevent React from actually cleaning up correctly."),Object(o.b)("p",null,"Inside, we define two more async functions to fetch issues and the open issues count, and call them both. We then wait for both functions to resolve successfully. (There's a few other ways we could have organized this logic, but this was sufficient for the example.)"),Object(o.b)("h3",{id:"thinking-in-thunks"},"Thinking in Thunks"),Object(o.b)("h4",{id:"what-is-a-thunk"},'What is a "Thunk"?'),Object(o.b)("p",null,"The Redux core (ie, ",Object(o.b)("inlineCode",{parentName:"p"},"createStore"),") is completely synchronous. When you call ",Object(o.b)("inlineCode",{parentName:"p"},"store.dispatch()"),", the store runs the root reducer, saves the return value, runs the subscriber callbacks, and returns, with no pause. By default, any asynchronicity has to happen outside of the store."),Object(o.b)("p",null,"But, what if you want to have async logic interact with the store by dispatching or checking the current store state? That's where ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://redux.js.org/advanced/middleware"}),"Redux middleware")," come in. They extend the store, and allow you to:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Execute extra logic when any action is dispatched (such as logging the action and state)"),Object(o.b)("li",{parentName:"ul"},"Pause, modify, delay, replace, or halt dispatched actions"),Object(o.b)("li",{parentName:"ul"},"Write extra code that has access to ",Object(o.b)("inlineCode",{parentName:"li"},"dispatch")," and ",Object(o.b)("inlineCode",{parentName:"li"},"getState")),Object(o.b)("li",{parentName:"ul"},"Teach ",Object(o.b)("inlineCode",{parentName:"li"},"dispatch")," how to accept other values besides plain action objects, such as functions and promises, by intercepting them and dispatching real action objects instead")),Object(o.b)("p",null,"The most common Redux middleware is ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/reduxjs/redux-thunk"}),Object(o.b)("inlineCode",{parentName:"a"},"redux-thunk")),'. The word "thunk" means "a function that delays a calculation until later". In our case, adding the thunk middleware to our Redux store lets us pass functions directly to ',Object(o.b)("inlineCode",{parentName:"p"},"store.dispatch()"),'. The thunk middleware will see the function, prevent it from actually reaching the "real" store, and call our function and pass in ',Object(o.b)("inlineCode",{parentName:"p"},"dispatch")," and ",Object(o.b)("inlineCode",{parentName:"p"},"getState"),' as arguments. So, a "thunk function" looks like this:'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"function exampleThunkFunction(dispatch, getState) {\n  // do something useful with dispatching or the store state here\n}\n\n// normally an error, but okay if the thunk middleware is added\nstore.dispatch(exampleThunkFunction)\n")),Object(o.b)("p",null,"Inside of a thunk function, you can write any code you want. The most common usage would be fetching some data via an AJAX call, and dispatching an action to load that data into the Redux store. The ",Object(o.b)("inlineCode",{parentName:"p"},"async/await")," syntax makes it easier to write thunks that do AJAX calls."),Object(o.b)("p",null,"Normally, we don't write action objects directly in our code - we use action creator functions to make them, and use them like ",Object(o.b)("inlineCode",{parentName:"p"},"dispatch(addTodo())"),'. In the same way, we typically write "thunk action creator" functions that return the thunk functions, like:'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"function exampleThunk() {\n  return function exampleThunkFunction(dispatch, getState) {\n    // do something useful with dispatching or the store state here\n  }\n}\n\n// normally an error, but okay if the thunk middleware is added\nstore.dispatch(exampleThunk())\n")),Object(o.b)("h4",{id:"why-use-thunks"},"Why Use Thunks?"),Object(o.b)("p",null,"You might be wondering what the point of all this is. There's a few reasons to use thunks:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Thunks allow us to write reusable logic that interacts with ",Object(o.b)("em",{parentName:"li"},"a")," Redux store, but without needing to reference a specific store instance."),Object(o.b)("li",{parentName:"ul"},"Thunks enable us to move more complex logic outside of our components"),Object(o.b)("li",{parentName:"ul"},"From a component's point of view, it doesn't care whether it's dispatching a plain action or kicking off some async logic - it just calls ",Object(o.b)("inlineCode",{parentName:"li"},"dispatch(doSomething())")," and moves on."),Object(o.b)("li",{parentName:"ul"},"Thunks can return values like promises, allowing logic inside the component to wait for something else to finish.")),Object(o.b)("p",null,"For further explanations, see ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/reduxjs/redux-thunk#why-do-i-need-this"}),"these articles explaining thunks in the ",Object(o.b)("inlineCode",{parentName:"a"},"redux-thunk")," documentation"),"."),Object(o.b)("p",null,"There are many other kinds of Redux middleware that add async capabilities. The most popular are ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://redux-saga.js.org/"}),Object(o.b)("inlineCode",{parentName:"a"},"redux-saga")),", which uses generator functions, and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://redux-observable.js.org/"}),Object(o.b)("inlineCode",{parentName:"a"},"redux-observable")),", which uses RxJS observables. For some comparisons, see the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://redux.js.org/faq/actions#what-async-middleware-should-i-use-how-do-you-decide-between-thunks-sagas-observables-or-something-else"}),'Redux FAQ entry on "how do I choose an async middleware?"'),"."),Object(o.b)("p",null,"However, while sagas and observables are useful, most apps do not need the power and capabilities they provide. So, ",Object(o.b)("strong",{parentName:"p"},"thunks are\nthe default recommended approach for writing async logic with Redux"),"."),Object(o.b)("h4",{id:"writing-thunks-in-redux-toolkit"},"Writing Thunks in Redux Toolkit"),Object(o.b)("p",null,"Writing thunk functions requires that the ",Object(o.b)("inlineCode",{parentName:"p"},"redux-thunk")," middleware be added to the store as part of the setup process. Redux Toolkit's ",Object(o.b)("inlineCode",{parentName:"p"},"configureStore")," function does automatically - ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/redux-toolkit/api/getDefaultMiddleware"}),Object(o.b)("inlineCode",{parentName:"a"},"thunk")," is one of the default middleware"),"."),Object(o.b)("p",null,"However, Redux Toolkit does not currently provide any special functions or syntax for writing thunk functions. In particular, they cannot be defined as part of a ",Object(o.b)("inlineCode",{parentName:"p"},"createSlice()")," call. You have to write them separate from the reducer logic."),Object(o.b)("p",null,'In a typical Redux app, thunk action creators are usually defined in an "actions" file, alongside the plain action creators. Thunks typically dispatch plain actions, such as ',Object(o.b)("inlineCode",{parentName:"p"},"dispatch(dataLoaded(response.data))"),"."),Object(o.b)("p",null,'Because we don\'t have separate "actions" files, it makes sense to write these thunks directly in our "slice" files. That way, they have access to the plain action creators from the slice, and it\'s easy to find where the thunk function lives.'),Object(o.b)("h3",{id:"logic-for-fetching-github-repo-details"},"Logic for Fetching Github Repo Details"),Object(o.b)("h4",{id:"adding-a-reusable-thunk-function-type"},"Adding a Reusable Thunk Function Type"),Object(o.b)("p",null,"Since the thunk middleware is already set up, we don't have to do any work there. However, the TypeScript types for thunks are kind of long and confusing, and we'd normally have to repeat the same type declaration for every thunk function we write."),Object(o.b)("p",null,"Before we go any further, let's add a type declaration we can reuse instead."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Add_AppThunk_type~1..reduxjs:Add_AppThunk_type"}),"Add AppThunk type")))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"app/store.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff"}),"-import { configureStore } from '@reduxjs/toolkit'\n+import { configureStore, Action } from '@reduxjs/toolkit'\n+import { ThunkAction } from 'redux-thunk'\n\n-import rootReducer from './rootReducer'\n+import rootReducer, { RootState } from './rootReducer'\n\nexport type AppDispatch = typeof store.dispatch\n\n+export type AppThunk = ThunkAction<void, RootState, unknown, Action<string>>\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"AppThunk"),' type declares that the "action" that we\'re using is specifically a thunk function. The thunk is customized with some additional type parameters:'),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Return value: the thunk doesn't return anything"),Object(o.b)("li",{parentName:"ol"},"State type for ",Object(o.b)("inlineCode",{parentName:"li"},"getState"),": returns our ",Object(o.b)("inlineCode",{parentName:"li"},"RootState")," type"),Object(o.b)("li",{parentName:"ol"},'"Extra argument": the thunk middleware can be customized to pass in an extra value, but we aren\'t doing that in this app'),Object(o.b)("li",{parentName:"ol"},"Action types accepted by ",Object(o.b)("inlineCode",{parentName:"li"},"dispatch"),": any action whose ",Object(o.b)("inlineCode",{parentName:"li"},"type")," is a string.")),Object(o.b)("p",null,"There are many cases where you would want different type settings here, but these are probably the most common settings. This way, we can avoid repeating that same type declaration every time we write a thunk."),Object(o.b)("h4",{id:"adding-the-repo-details-slice"},"Adding the Repo Details Slice"),Object(o.b)("p",null,"Now that we have that type, we can write a slice of state for fetching details on a repo."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Add_a_slice_for_storing_repo_details~1..reduxjs:Add_a_slice_for_storing_repo_details"}),"Add a slice for storing repo details")))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"features/repoSearch/repoDetailsSlice.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\nimport { AppThunk } from 'app/store'\n\nimport { RepoDetails, getRepoDetails } from 'api/githubAPI'\n\ninterface RepoDetailsState {\n  openIssuesCount: number\n  error: string | null\n}\n\nconst initialState: RepoDetailsState = {\n  openIssuesCount: -1,\n  error: null\n}\n\nconst repoDetails = createSlice({\n  name: 'repoDetails',\n  initialState,\n  reducers: {\n    getRepoDetailsSuccess(state, action: PayloadAction<RepoDetails>) {\n      state.openIssuesCount = action.payload.open_issues_count\n      state.error = null\n    },\n    getRepoDetailsFailed(state, action: PayloadAction<string>) {\n      state.openIssuesCount = -1\n      state.error = action.payload\n    }\n  }\n})\n\nexport const {\n  getRepoDetailsSuccess,\n  getRepoDetailsFailed\n} = repoDetails.actions\n\nexport default repoDetails.reducer\n\nexport const fetchIssuesCount = (\n  org: string,\n  repo: string\n): AppThunk => async dispatch => {\n  try {\n    const repoDetails = await getRepoDetails(org, repo)\n    dispatch(getRepoDetailsSuccess(repoDetails))\n  } catch (err) {\n    dispatch(getRepoDetailsFailed(err.toString()))\n  }\n}\n")),Object(o.b)("p",null,"The first part of this should look straightforward. We declare our slice state shape, the initial state value, and write a slice with reducers that store the open issues count or an error string, then export the action creators and reducer."),Object(o.b)("p",null,"Down at the bottom, we have our first data fetching thunk. The important things to notice here are:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"The thunk is defined separately from the slice"),", since RTK currently has no special syntax for defining thunks as part of a slice."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"We declare the thunk action creator as an arrow function, and use the ",Object(o.b)("inlineCode",{parentName:"strong"},"AppThunk")," type we just created.")," You can use either arrow functions or the ",Object(o.b)("inlineCode",{parentName:"li"},"function")," keyword to write thunk functions and thunk action creators, so we could also have written this as ",Object(o.b)("inlineCode",{parentName:"li"},"function fetchIssuesCount() : AppThunk")," instead."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"We use the ",Object(o.b)("inlineCode",{parentName:"strong"},"async/await")," syntax for the thunk function itself.")," Again, this isn't required, but ",Object(o.b)("inlineCode",{parentName:"li"},"async/await")," usually results in simpler code than nested Promise ",Object(o.b)("inlineCode",{parentName:"li"},".then()")," chains."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Inside the thunk, we dispatch the plain action creators that were generated by the ",Object(o.b)("inlineCode",{parentName:"strong"},"createSlice")," call"),".")),Object(o.b)("p",null,"While not shown, we also add the slice reducer to our root reducer."),Object(o.b)("h4",{id:"async-error-handling-logic-in-thunks"},"Async Error Handling Logic in Thunks"),Object(o.b)("p",null,"There is one potential flaw with the ",Object(o.b)("inlineCode",{parentName:"p"},"fetchIssuesCount()")," thunk as written. The ",Object(o.b)("inlineCode",{parentName:"p"},"try/catch")," block will currently catch any errors thrown\nby ",Object(o.b)("inlineCode",{parentName:"p"},"getRepoDetails()")," (such as an actual failed AJAX call), but it will also catch any errors that occur inside the dispatch of ",Object(o.b)("inlineCode",{parentName:"p"},"getRepoDetailsSuccess()"),". In both cases, it will end up dispatch ",Object(o.b)("inlineCode",{parentName:"p"},"getRepoDetailsFailed()"),". This may not be the desired way to handle errors, as it might show a misleading reason for what the actual error was."),Object(o.b)("p",null,"There are some possible ways to restructure the code to avoid this problem. First, the ",Object(o.b)("inlineCode",{parentName:"p"},"await")," could be switched to a standard promise chain, with separate callbacks passed in for the success and failure cases:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"getRepoDetails(org, repo).then(\n  // success callback\n  repoDetails => dispatch(getRepoDetailsSuccess(repoDetails)),\n  // error callback\n  err => dispatch(getRepoDetailsFailed(err.toString()))\n)\n")),Object(o.b)("p",null,"Or, the thunk could be rewritten to only dispatch if no errors were caught:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"})," let repoDetails\n  try {\n    repoDetails = await getRepoDetails(org, repo)\n  } catch (err) {\n    dispatch(getRepoDetailsFailed(err.toString()))\n    return\n  }\n  dispatch(getRepoDetailsSuccess(repoDetails))\n}\n")),Object(o.b)("p",null,"For sake of simplicity, we'll stick with the logic as-is for the rest of the tutorial."),Object(o.b)("h3",{id:"fetching-repo-details-in-the-issues-list"},"Fetching Repo Details in the Issues List"),Object(o.b)("p",null,"Now that the repo details slice exists, we can use it in the ",Object(o.b)("inlineCode",{parentName:"p"},"<IssuesListPage>")," component."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Update_IssuesListPage_to_fetch_repo_details_via_Redux~1..reduxjs:Update_IssuesListPage_to_fetch_repo_details_via_Redux"}),"Update IssuesListPage to fetch repo details via Redux")))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"features/issuesList/IssuesListPage.tsx")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff"}),"import React, { useState, useEffect } from 'react'\n+import { useSelector, useDispatch } from 'react-redux'\n\n-import { getIssues, getRepoDetails, IssuesResult } from 'api/githubAPI'\n+import { getIssues, IssuesResult } from 'api/githubAPI'\n\n+import { fetchIssuesCount } from 'features/repoSearch/repoDetailsSlice'\n+import { RootState } from 'app/rootReducer'\n\n// omit code\n\nexport const IssuesListPage = ({\n  org,\n  repo,\n  page = 1,\n  setJumpToPage,\n  showIssueComments\n}: ILProps) => {\n+ const dispatch = useDispatch()\n\n  const [issuesResult, setIssues] = useState<IssuesResult>({\n    pageLinks: null,\n    pageCount: 1,\n    issues: []\n  })\n- const [numIssues, setNumIssues] = useState<number>(-1)\n  const [isLoading, setIsLoading] = useState<boolean>(false)\n  const [issuesError, setIssuesError] = useState<Error | null>(null)\n+ const openIssueCount = useSelector(\n+   (state: RootState) => state.repoDetails.openIssuesCount\n+ )\n\n  useEffect(() => {\n    async function fetchEverything() {\n      async function fetchIssues() {\n        const issuesResult = await getIssues(org, repo, page)\n        setIssues(issuesResult)\n      }\n\n-     async function fetchIssueCount() {\n-       const repoDetails = await getRepoDetails(org, repo)\n-       setNumIssues(repoDetails.open_issues_count)\n-     }\n\n      try {\n-       await Promise.all([fetchIssues(), fetchIssueCount()])\n+       await Promise.all([\n+         fetchIssues(),\n+         dispatch(fetchIssuesCount(org, repo))\n+       ])\n        setIssuesError(null)\n      } catch (err) {\n        console.error(err)\n        setIssuesError(err)\n      } finally {\n        setIsLoading(false)\n      }\n    }\n\n    setIsLoading(true)\n\n    fetchEverything()\n- }, [org, repo, page])\n+ }, [org, repo, page, dispatch])\n")),Object(o.b)("p",null,"In ",Object(o.b)("inlineCode",{parentName:"p"},"<IssuesListPage>"),", we import the new ",Object(o.b)("inlineCode",{parentName:"p"},"fetchIssuesCount")," thunk, and rewrite the component to read the open issues count value from the Redux store."),Object(o.b)("p",null,"Inside our ",Object(o.b)("inlineCode",{parentName:"p"},"useEffect"),", we drop the ",Object(o.b)("inlineCode",{parentName:"p"},"fetchIssueCount")," function, and dispatch ",Object(o.b)("inlineCode",{parentName:"p"},"fetchIssuesCount")," instead."),Object(o.b)("h3",{id:"logic-for-fetching-issues-for-a-repo"},"Logic for Fetching Issues for a Repo"),Object(o.b)("p",null,"Next up, we need to replace the logic for fetching a list of open issues."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Add_a_slice_for_tracking_issues_state~1..reduxjs:Add_a_slice_for_tracking_issues_state"}),"Add a slice for tracking issues state")))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"features/issuesList/issuesSlice.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { Links } from 'parse-link-header'\n\nimport { Issue, IssuesResult, getIssue, getIssues } from 'api/githubAPI'\nimport { AppThunk } from 'app/store'\n\ninterface IssuesState {\n  issuesByNumber: Record<number, Issue>\n  currentPageIssues: number[]\n  pageCount: number\n  pageLinks: Links | null\n  isLoading: boolean\n  error: string | null\n}\n\nconst issuesInitialState: IssuesState = {\n  issuesByNumber: {},\n  currentPageIssues: [],\n  pageCount: 0,\n  pageLinks: {},\n  isLoading: false,\n  error: null\n}\n\nfunction startLoading(state: IssuesState) {\n  state.isLoading = true\n}\n\nfunction loadingFailed(state: IssuesState, action: PayloadAction<string>) {\n  state.isLoading = false\n  state.error = action.payload\n}\n\nconst issues = createSlice({\n  name: 'issues',\n  initialState: issuesInitialState,\n  reducers: {\n    getIssueStart: startLoading,\n    getIssuesStart: startLoading,\n    getIssueSuccess(state, { payload }: PayloadAction<Issue>) {\n      const { number } = payload\n      state.issuesByNumber[number] = payload\n      state.isLoading = false\n      state.error = null\n    },\n    getIssuesSuccess(state, { payload }: PayloadAction<IssuesResult>) {\n      const { pageCount, issues, pageLinks } = payload\n      state.pageCount = pageCount\n      state.pageLinks = pageLinks\n      state.isLoading = false\n      state.error = null\n\n      issues.forEach(issue => {\n        state.issuesByNumber[issue.number] = issue\n      })\n\n      state.currentPageIssues = issues.map(issue => issue.number)\n    },\n    getIssueFailure: loadingFailed,\n    getIssuesFailure: loadingFailed\n  }\n})\n\nexport const {\n  getIssuesStart,\n  getIssuesSuccess,\n  getIssueStart,\n  getIssueSuccess,\n  getIssueFailure,\n  getIssuesFailure\n} = issues.actions\n\nexport default issues.reducer\n\nexport const fetchIssues = (\n  org: string,\n  repo: string,\n  page?: number\n): AppThunk => async dispatch => {\n  try {\n    dispatch(getIssuesStart())\n    const issues = await getIssues(org, repo, page)\n    dispatch(getIssuesSuccess(issues))\n  } catch (err) {\n    dispatch(getIssuesFailure(err.toString()))\n  }\n}\n\nexport const fetchIssue = (\n  org: string,\n  repo: string,\n  number: number\n): AppThunk => async dispatch => {\n  try {\n    dispatch(getIssueStart())\n    const issue = await getIssue(org, repo, number)\n    dispatch(getIssueSuccess(issue))\n  } catch (err) {\n    dispatch(getIssueFailure(err.toString()))\n  }\n}\n")),Object(o.b)("p",null,"This slice is a bit longer, but it's the same basic approach as before: write the slice with reducers that handle API call results, then write thunks that do the fetching and dispatch actions with those results. The only new and interesting bits in this slice are:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},'Our "start loading" and "loading failed" reducer logic is the same for both the single issue and multiple issue fetch cases. So, we write those functions outside the slice once, then reuse them multiple times inside the ',Object(o.b)("inlineCode",{parentName:"li"},"reducers")," object."),Object(o.b)("li",{parentName:"ul"},"The Github API returns an array of issue entries, but we ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape"}),'want to store the data in a "normalized" structure to make it easy to look up an issue by its number'),". In this case, we use a plain object as a lookup table, by declaring that it is a ",Object(o.b)("inlineCode",{parentName:"li"},"Record<number, Issue>"),".")),Object(o.b)("h3",{id:"fetching-issues-in-the-issues-list"},"Fetching Issues in the Issues List"),Object(o.b)("p",null,"Now we can finish converting the ",Object(o.b)("inlineCode",{parentName:"p"},"<IssuesListPage>")," component by swapping out the issues fetching logic."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Update_IssuesListPage_to_fetch_issues_data_via_Redux~1..reduxjs:Update_IssuesListPage_to_fetch_issues_data_via_Redux"}),"Update IssuesListPage to fetch issues data via Redux")))),Object(o.b)("p",null,"Let's look at the changes."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"features/issuesList/IssuesListPage.tsx")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff"}),"-import React, { useState, useEffect } from 'react'\n+import React, { useEffect } from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\n-import { getIssues, IssuesResult } from 'api/githubAPI'\n\nimport { fetchIssuesCount } from 'features/repoSearch/repoDetailsSlice'\nimport { RootState } from 'app/rootReducer'\n\nimport { IssuesPageHeader } from './IssuesPageHeader'\nimport { IssuesList } from './IssuesList'\nimport { IssuePagination, OnPageChangeCallback } from './IssuePagination'\n+import { fetchIssues } from './issuesSlice'\n\n// omit code\n\n  const dispatch = useDispatch()\n\n- const [issuesResult, setIssues] = useState<IssuesResult>({\n-   pageLinks: null,\n-   pageCount: 1,\n-   issues: []\n- })\n- const [isLoading, setIsLoading] = useState<boolean>(false)\n- const [issuesError, setIssuesError] = useState<Error | null>(null)\n+ const {\n+   currentPageIssues,\n+   isLoading,\n+   error: issuesError,\n+   issuesByNumber,\n+   pageCount\n+ } = useSelector((state: RootState) => state.issues)\n\n\n  const openIssueCount = useSelector(\n    (state: RootState) => state.repoDetails.openIssuesCount\n  )\n\n- const { issues, pageCount } = issuesResult\n+ const issues = currentPageIssues.map(\n+   issueNumber => issuesByNumber[issueNumber]\n+ )\n\n  useEffect(() => {\n-   async function fetchEverything() {\n-     async function fetchIssues() {\n-       const issuesResult = await getIssues(org, repo, page)\n-       setIssues(issuesResult)\n-     }\n-\n-     try {\n-       await Promise.all([\n-        fetchIssues(),\n-        dispatch(fetchIssuesCount(org, repo))\n-       ])\n-       setIssuesError(null)\n-     } catch (err) {\n-       console.error(err)\n-       setIssuesError(err)\n-     } finally {\n-       setIsLoading(false)\n-     }\n-   }\n-\n-    setIsLoading(true)\n-\n-    fetchEverything()\n+    dispatch(fetchIssues(org, repo, page))\n+    dispatch(fetchIssuesCount(org, repo))\n  }, [org, repo, page, dispatch])\n")),Object(o.b)("p",null,"We remove the remaining ",Object(o.b)("inlineCode",{parentName:"p"},"useState")," hooks from ",Object(o.b)("inlineCode",{parentName:"p"},"<IssuesListPage>"),", add another ",Object(o.b)("inlineCode",{parentName:"p"},"useSelector"),' to retrieve the actual issues data from the Redux store, and construct the list of issues to render by mapping over the "current page issue IDs" array to look up each issue object by its ID.'),Object(o.b)("p",null,"In our ",Object(o.b)("inlineCode",{parentName:"p"},"useEffect"),", we delete the rest of the data fetching logic that's directly in the component, and just dispatch both data fetching thunks."),Object(o.b)("p",null,'This simplifies the logic in the component, but it didn\'t remove the work being done - it just moved it elsewhere. Again, it\'s not that either approach is "right" or "wrong" - it\'s just a question of where you want the data and the logic to live, and which approach is more maintainable for your app and situation.'),Object(o.b)("h2",{id:"converting-the-issue-details-page"},"Converting the Issue Details Page"),Object(o.b)("p",null,"The last major chunk of work left in the conversion is the ",Object(o.b)("inlineCode",{parentName:"p"},"<IssueDetailsPage>")," component. Let's take a look at what it does."),Object(o.b)("h3",{id:"reviewing-the-issue-details-component"},"Reviewing the Issue Details Component"),Object(o.b)("p",null,"Here's the current first half of ",Object(o.b)("inlineCode",{parentName:"p"},"<IssueDetailsPage>"),", containing the state and data fetching:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"export const IssueDetailsPage = ({\n  org,\n  repo,\n  issueId,\n  showIssuesList\n}: IDProps) => {\n  const [issue, setIssue] = useState<Issue | null>(null)\n  const [comments, setComments] = useState<Comment[]>([])\n  const [commentsError, setCommentsError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    async function fetchIssue() {\n      try {\n        setCommentsError(null)\n        const issue = await getIssue(org, repo, issueId)\n        setIssue(issue)\n      } catch (err) {\n        setCommentsError(err)\n      }\n    }\n\n    fetchIssue()\n  }, [org, repo, issueId])\n\n  useEffect(() => {\n    async function fetchComments() {\n      if (issue !== null) {\n        const comments = await getComments(issue.comments_url)\n        setComments(comments)\n      }\n    }\n\n    fetchComments()\n  }, [issue])\n\n  // omit rendering\n}\n")),Object(o.b)("p",null,"It's very similar to ",Object(o.b)("inlineCode",{parentName:"p"},"<IssuesListPage>"),". We store the current displayed ",Object(o.b)("inlineCode",{parentName:"p"},"Issue"),", the fetched comments, and a potential error. We have ",Object(o.b)("inlineCode",{parentName:"p"},"useEffect")," hooks that fetch the current issue by its ID, and fetch the comments whenever the issue changes."),Object(o.b)("h3",{id:"fetching-the-current-issue"},"Fetching the Current Issue"),Object(o.b)("p",null,"We conveniently already have the Redux logic for fetching a single issue - we wrote that already as part of ",Object(o.b)("inlineCode",{parentName:"p"},"issuesSlice.ts"),". So, we can immediately jump straight to using that here in ",Object(o.b)("inlineCode",{parentName:"p"},"<IssueDetailsPage>"),"."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Update_IssueDetailsPage_to_fetch_issue_data_via_Redux~1..reduxjs:Update_IssueDetailsPage_to_fetch_issue_data_via_Redux"}),"Update IssueDetailsPage to fetch issue data via Redux")))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"features/issueDetails/IssueDetailsPage.tsx")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff"}),"import React, { useState, useEffect } from 'react'\n+import { useSelector, useDispatch } from 'react-redux'\nimport ReactMarkdown from 'react-markdown'\nimport classnames from 'classnames'\n\nimport { insertMentionLinks } from 'utils/stringUtils'\n-import { getIssue, getComments, Issue, Comment } from 'api/githubAPI'\n+import { getComments, Comment } from 'api/githubAPI'\nimport { IssueLabels } from 'components/IssueLabels'\n+import { RootState } from 'app/rootReducer'\n+import { fetchIssue } from 'features/issuesList/issuesSlice'\n\n\nexport const IssueDetailsPage = ({\n  org,\n  repo,\n  issueId,\n  showIssuesList\n}: IDProps) => {\n- const [issue, setIssue] = useState<Issue | null>(null)\n  const [comments, setComments] = useState<Comment[]>([])\n- const [commentsError, setCommentsError] = useState<Error | null>(null)\n\n+ const dispatch = useDispatch()\n\n+ const issue = useSelector(\n+   (state: RootState) => state.issues.issuesByNumber[issueId]\n+ )\n\n  useEffect(() => {\n-   async function fetchIssue() {\n-     try {\n-       setCommentsError(null)\n-       const issue = await getIssue(org, repo, issueId)\n-       setIssue(issue)\n-     } catch (err) {\n-       setCommentsError(err)\n-     }\n-    }\n-    fetchIssue()\n+   if (!issue) {\n+      dispatch(fetchIssue(org, repo, issueId))\n+   }\n+   // Since we may have the issue already, ensure we're scrolled to the top\n+   window.scrollTo({ top: 0 })\n- }, [org, repo, issueId])\n+ }, [org, repo, issueId, issue, dispatch])\n")),Object(o.b)("p",null,"We continue the usual pattern. We drop the existing ",Object(o.b)("inlineCode",{parentName:"p"},"useState")," hooks, pull in ",Object(o.b)("inlineCode",{parentName:"p"},"useDispatch")," and the necessary state via ",Object(o.b)("inlineCode",{parentName:"p"},"useSelector"),", and dispatch the ",Object(o.b)("inlineCode",{parentName:"p"},"fetchIssue")," thunk to fetch data."),Object(o.b)("p",null,"Interestingly, there's actually a bit of a change in behavior here. The original React code was storing the fetched issues in ",Object(o.b)("inlineCode",{parentName:"p"},"<IssuesListPage>"),", and ",Object(o.b)("inlineCode",{parentName:"p"},"<IssueDetailsPage>")," was always having to do a separate fetch for its own issue. Because we're now storing issues in the Redux store, most of the time the listed issue ",Object(o.b)("em",{parentName:"p"},"should")," be already cached, and we don't even need to fetch it. Now, it's totally possible to do something similar with just React - all we'd have to do is pass the issue down from the parent component. Still, having that data in Redux makes it easier to do the caching."),Object(o.b)("p",null,"(As an interesting side note: the original code always caused the page to jump back to the top, because the issue didn't exist during the first render, so there was no content. If the issue ",Object(o.b)("em",{parentName:"p"},"does")," exist and we render it right away, the page may retain the scroll position from the issues list, so we have to enforce scrolling back to the top.)"),Object(o.b)("h3",{id:"logic-for-fetching-comments"},"Logic for Fetching Comments"),Object(o.b)("p",null,"We have one more slice left to write - we need to fetch and store comments for the current issue."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Add_a_slice_for_tracking_comments_data~1..reduxjs:Add_a_slice_for_tracking_comments_data"}),"Add a slice for tracking comments data")))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"features/issueDetails/commentsSlice.ts")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\nimport { Comment, getComments, Issue } from 'api/githubAPI'\nimport { AppThunk } from 'app/store'\n\ninterface CommentsState {\n  commentsByIssue: Record<number, Comment[] | undefined>\n  loading: boolean\n  error: string | null\n}\n\ninterface CommentLoaded {\n  issueId: number\n  comments: Comment[]\n}\n\nconst initialState: CommentsState = {\n  commentsByIssue: {},\n  loading: false,\n  error: null\n}\n\nconst comments = createSlice({\n  name: 'comments',\n  initialState,\n  reducers: {\n    getCommentsStart(state) {\n      state.loading = true\n      state.error = null\n    },\n    getCommentsSuccess(state, action: PayloadAction<CommentLoaded>) {\n      const { comments, issueId } = action.payload\n      state.commentsByIssue[issueId] = comments\n      state.loading = false\n      state.error = null\n    },\n    getCommentsFailure(state, action: PayloadAction<string>) {\n      state.loading = false\n      state.error = action.payload\n    }\n  }\n})\n\nexport const {\n  getCommentsStart,\n  getCommentsSuccess,\n  getCommentsFailure\n} = comments.actions\nexport default comments.reducer\n\nexport const fetchComments = (issue: Issue): AppThunk => async dispatch => {\n  try {\n    dispatch(getCommentsStart())\n    const comments = await getComments(issue.comments_url)\n    dispatch(getCommentsSuccess({ issueId: issue.number, comments }))\n  } catch (err) {\n    dispatch(getCommentsFailure(err))\n  }\n}\n")),Object(o.b)("p",null,"The slice should look pretty familiar at this point. Our main bit of state is a lookup table of comments keyed by an issue ID. After the slice, we add a thunk to fetch the comments for a given issue, and dispatch the action to save the resulting array in the slice."),Object(o.b)("h3",{id:"fetching-the-issue-comments"},"Fetching the Issue Comments"),Object(o.b)("p",null,"The final step is to swap the comments fetching logic in ",Object(o.b)("inlineCode",{parentName:"p"},"<IssueDetailsPage>"),"."),Object(o.b)("blockquote",null,Object(o.b)("ul",{parentName:"blockquote"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/reduxjs/rtk-github-issues-example/compare/Update_IssueDetailsPage_to_fetch_comments_via_Redux~1..reduxjs:Update_IssueDetailsPage_to_fetch_comments_via_Redux"}),"Update IssueDetailsPage to fetch comments via Redux")))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"features/issueDetails/IssueDetailsPage.tsx")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-diff"}),"-import React, { useState, useEffect } from 'react'\n+import React, { useEffect } from 'react'\n-import { useSelector, useDispatch } from 'react-redux'\n+import { useSelector, useDispatch, shallowEqual } from 'react-redux'\nimport ReactMarkdown from 'react-markdown'\nimport classnames from 'classnames'\n\nimport { insertMentionLinks } from 'utils/stringUtils'\n-import { getComments, Comment } from 'api/githubAPI'\nimport { IssueLabels } from 'components/IssueLabels'\nimport { RootState } from 'app/rootReducer'\nimport { fetchIssue } from 'features/issuesList/issuesSlice'\n\nimport { IssueMeta } from './IssueMeta'\nimport { IssueComments } from './IssueComments'\n+import { fetchComments } from './commentsSlice'\n\nexport const IssueDetailsPage = ({\n  org,\n  repo,\n  issueId,\n  showIssuesList\n}: IDProps) => {\n- const [comments, setComments] = useState<Comment[]>([])\n- const [commentsError] = useState<Error | null>(null)\n-\n  const dispatch = useDispatch()\n\n  const issue = useSelector(\n    (state: RootState) => state.issues.issuesByNumber[issueId]\n  )\n\n+ const { commentsLoading, commentsError, comments } = useSelector(\n+   (state: RootState) => {\n+     return {\n+       commentsLoading: state.comments.loading,\n+       commentsError: state.comments.error,\n+       comments: state.comments.commentsByIssue[issueId]\n+     }\n+   },\n+   shallowEqual\n+ )\n\n// omit effect\n  useEffect(() => {\n-   async function fetchComments() {\n-     if (issue) {\n-       const comments = await getComments(issue.comments_url)\n-       setComments(comments)\n-     }\n-   }\n-   fetchComments()\n+   if (issue) {\n+     dispatch(fetchComments(issue))\n+   }\n- }, [issue])\n+ }, [issue, dispatch])\n")),Object(o.b)("p",null,"We add another ",Object(o.b)("inlineCode",{parentName:"p"},"useSelector")," hook to pull out the current comments data. In this case, we need three different pieces: the loading flag, a potential error, and the actual comments array for this issue."),Object(o.b)("p",null,"However, this leads to a performance problem. Every time this selector runs, it returns a new object: ",Object(o.b)("inlineCode",{parentName:"p"},"{commentsLoading, commentsError, comments}"),". ",Object(o.b)("strong",{parentName:"p"},"Unlike ",Object(o.b)("inlineCode",{parentName:"strong"},"connect"),", ",Object(o.b)("inlineCode",{parentName:"strong"},"useSelector")," relies on reference equality by default.")," So, returning a new object will cause this component to rerender every time an action is dispatched, even if the comments are the same!"),Object(o.b)("p",null,"There's a few ways to fix this:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"We could write those as separate ",Object(o.b)("inlineCode",{parentName:"li"},"useSelector")," calls"),Object(o.b)("li",{parentName:"ul"},"We could use a memoized selector, such as ",Object(o.b)("inlineCode",{parentName:"li"},"createSelector")," from Reselect"),Object(o.b)("li",{parentName:"ul"},"We can use the React-Redux ",Object(o.b)("inlineCode",{parentName:"li"},"shallowEqual")," function to compare the results, so that the re-render only happens if the object's ",Object(o.b)("em",{parentName:"li"},"contents")," have changed.")),Object(o.b)("p",null,"In this case, we'll add ",Object(o.b)("inlineCode",{parentName:"p"},"shallowEqual")," as the comparison function for ",Object(o.b)("inlineCode",{parentName:"p"},"useSelector"),"."),Object(o.b)("h2",{id:"summary"},"Summary"),Object(o.b)("p",null,"And with that, we're done! The entire Github Issues app should now be fetching its data via thunks, storing the data in Redux, and interacting with the store via React-Redux hooks. We have Typescript types for our Github API calls, the API types are being used for the Redux state slices, and the store state types are being used in our React components."),Object(o.b)("p",null,"There's more that could be done to add more type safety if we wanted (like trying to constrain which possible action types can be passed to ",Object(o.b)("inlineCode",{parentName:"p"},"dispatch"),'), but this gives us a reasonable "80% solution" without too much extra effort.'),Object(o.b)("p",null,"Hopefully you now have a solid understanding of how Redux Toolkit looks in a real world application."),Object(o.b)("p",null,"Let's wrap this up with one more look at the complete source code and the running app:"),Object(o.b)("iframe",{src:"https://codesandbox.io/embed/rtk-github-issues-example-03-final-ihttc?fontsize=14&hidenavigation=1&module=%2Fsrc%2Ffeatures%2FissueDetails%2FcommentsSlice.ts&theme=dark&view=editor",style:{width:"100%",height:"500px",border:0,borderRadius:"4px",overflow:"hidden"},title:"rtk-github-issues-example03-final",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Now, go out there and build something cool!")))}l.isMDXComponent=!0},89:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n(0),s=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var u=s.a.createContext({}),l=function(e){var t=s.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return s.a.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},b=s.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=l(n),b=a,h=p["".concat(r,".").concat(b)]||p[b]||d[b]||o;return n?s.a.createElement(h,i(i({ref:t},u),{},{components:n})):s.a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=b;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,r[1]=i;for(var u=2;u<o;u++)r[u]=n[u];return s.a.createElement.apply(null,r)}return s.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},90:function(e,t,n){"use strict";e.exports=n(91)},91:function(e,t,n){"use strict";var a=n(92),s="function"==typeof Symbol&&Symbol.for,o=s?Symbol.for("react.element"):60103,r=s?Symbol.for("react.portal"):60106,i=s?Symbol.for("react.fragment"):60107,c=s?Symbol.for("react.strict_mode"):60108,u=s?Symbol.for("react.profiler"):60114,l=s?Symbol.for("react.provider"):60109,p=s?Symbol.for("react.context"):60110,d=s?Symbol.for("react.concurrent_mode"):60111,b=s?Symbol.for("react.forward_ref"):60112,h=s?Symbol.for("react.suspense"):60113,m=s?Symbol.for("react.memo"):60115,f=s?Symbol.for("react.lazy"):60116,g="function"==typeof Symbol&&Symbol.iterator;function j(e,t,n,a,s,o,r,i){if(!e){if(e=void 0,void 0===t)e=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var c=[n,a,s,o,r,i],u=0;(e=Error(t.replace(/%s/g,(function(){return c[u++]})))).name="Invariant Violation"}throw e.framesToPop=1,e}}function O(e){for(var t=arguments.length-1,n="https://reactjs.org/docs/error-decoder.html?invariant="+e,a=0;a<t;a++)n+="&args[]="+encodeURIComponent(arguments[a+1]);j(!1,"Minified React error #"+e+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",n)}var y={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},w={};function v(e,t,n){this.props=e,this.context=t,this.refs=w,this.updater=n||y}function N(){}function k(e,t,n){this.props=e,this.context=t,this.refs=w,this.updater=n||y}v.prototype.isReactComponent={},v.prototype.setState=function(e,t){"object"!=typeof e&&"function"!=typeof e&&null!=e&&O("85"),this.updater.enqueueSetState(this,e,t,"setState")},v.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},N.prototype=v.prototype;var C=k.prototype=new N;C.constructor=k,a(C,v.prototype),C.isPureReactComponent=!0;var I={current:null},x={current:null},R=Object.prototype.hasOwnProperty,S={key:!0,ref:!0,__self:!0,__source:!0};function _(e,t,n){var a=void 0,s={},r=null,i=null;if(null!=t)for(a in void 0!==t.ref&&(i=t.ref),void 0!==t.key&&(r=""+t.key),t)R.call(t,a)&&!S.hasOwnProperty(a)&&(s[a]=t[a]);var c=arguments.length-2;if(1===c)s.children=n;else if(1<c){for(var u=Array(c),l=0;l<c;l++)u[l]=arguments[l+2];s.children=u}if(e&&e.defaultProps)for(a in c=e.defaultProps)void 0===s[a]&&(s[a]=c[a]);return{$$typeof:o,type:e,key:r,ref:i,props:s,_owner:x.current}}function T(e){return"object"==typeof e&&null!==e&&e.$$typeof===o}var P=/\/+/g,D=[];function A(e,t,n,a){if(D.length){var s=D.pop();return s.result=e,s.keyPrefix=t,s.func=n,s.context=a,s.count=0,s}return{result:e,keyPrefix:t,func:n,context:a,count:0}}function E(e){e.result=null,e.keyPrefix=null,e.func=null,e.context=null,e.count=0,10>D.length&&D.push(e)}function L(e,t,n,a){var s=typeof e;"undefined"!==s&&"boolean"!==s||(e=null);var i=!1;if(null===e)i=!0;else switch(s){case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case o:case r:i=!0}}if(i)return n(a,e,""===t?"."+q(e,0):t),1;if(i=0,t=""===t?".":t+":",Array.isArray(e))for(var c=0;c<e.length;c++){var u=t+q(s=e[c],c);i+=L(s,u,n,a)}else if(null===e||"object"!=typeof e?u=null:u="function"==typeof(u=g&&e[g]||e["@@iterator"])?u:null,"function"==typeof u)for(e=u.call(e),c=0;!(s=e.next()).done;)i+=L(s=s.value,u=t+q(s,c++),n,a);else"object"===s&&O("31","[object Object]"===(n=""+e)?"object with keys {"+Object.keys(e).join(", ")+"}":n,"");return i}function F(e,t,n){return null==e?0:L(e,"",t,n)}function q(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+(""+e).replace(/[=:]/g,(function(e){return t[e]}))}(e.key):t.toString(36)}function W(e,t){e.func.call(e.context,t,e.count++)}function M(e,t,n){var a=e.result,s=e.keyPrefix;e=e.func.call(e.context,t,e.count++),Array.isArray(e)?U(e,a,n,(function(e){return e})):null!=e&&(T(e)&&(e=function(e,t){return{$$typeof:o,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(e,s+(!e.key||t&&t.key===e.key?"":(""+e.key).replace(P,"$&/")+"/")+n)),a.push(e))}function U(e,t,n,a,s){var o="";null!=n&&(o=(""+n).replace(P,"$&/")+"/"),F(e,M,t=A(t,o,a,s)),E(t)}function H(){var e=I.current;return null===e&&O("321"),e}var $={Children:{map:function(e,t,n){if(null==e)return e;var a=[];return U(e,a,null,t,n),a},forEach:function(e,t,n){if(null==e)return e;F(e,W,t=A(null,null,t,n)),E(t)},count:function(e){return F(e,(function(){return null}),null)},toArray:function(e){var t=[];return U(e,t,null,(function(e){return e})),t},only:function(e){return T(e)||O("143"),e}},createRef:function(){return{current:null}},Component:v,PureComponent:k,createContext:function(e,t){return void 0===t&&(t=null),(e={$$typeof:p,_calculateChangedBits:t,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:l,_context:e},e.Consumer=e},forwardRef:function(e){return{$$typeof:b,render:e}},lazy:function(e){return{$$typeof:f,_ctor:e,_status:-1,_result:null}},memo:function(e,t){return{$$typeof:m,type:e,compare:void 0===t?null:t}},useCallback:function(e,t){return H().useCallback(e,t)},useContext:function(e,t){return H().useContext(e,t)},useEffect:function(e,t){return H().useEffect(e,t)},useImperativeHandle:function(e,t,n){return H().useImperativeHandle(e,t,n)},useDebugValue:function(){},useLayoutEffect:function(e,t){return H().useLayoutEffect(e,t)},useMemo:function(e,t){return H().useMemo(e,t)},useReducer:function(e,t,n){return H().useReducer(e,t,n)},useRef:function(e){return H().useRef(e)},useState:function(e){return H().useState(e)},Fragment:i,StrictMode:c,Suspense:h,createElement:_,cloneElement:function(e,t,n){null==e&&O("267",e);var s=void 0,r=a({},e.props),i=e.key,c=e.ref,u=e._owner;if(null!=t){void 0!==t.ref&&(c=t.ref,u=x.current),void 0!==t.key&&(i=""+t.key);var l=void 0;for(s in e.type&&e.type.defaultProps&&(l=e.type.defaultProps),t)R.call(t,s)&&!S.hasOwnProperty(s)&&(r[s]=void 0===t[s]&&void 0!==l?l[s]:t[s])}if(1===(s=arguments.length-2))r.children=n;else if(1<s){l=Array(s);for(var p=0;p<s;p++)l[p]=arguments[p+2];r.children=l}return{$$typeof:o,type:e.type,key:i,ref:c,props:r,_owner:u}},createFactory:function(e){var t=_.bind(null,e);return t.type=e,t},isValidElement:T,version:"16.8.6",unstable_ConcurrentMode:d,unstable_Profiler:u,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentDispatcher:I,ReactCurrentOwner:x,assign:a}},B={default:$},z=B&&$||B;e.exports=z.default||z},92:function(e,t,n){"use strict";var a=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable;function r(e){if(null==e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(t).map((function(e){return t[e]})).join(""))return!1;var a={};return"abcdefghijklmnopqrst".split("").forEach((function(e){a[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},a)).join("")}catch(s){return!1}}()?Object.assign:function(e,t){for(var n,i,c=r(e),u=1;u<arguments.length;u++){for(var l in n=Object(arguments[u]))s.call(n,l)&&(c[l]=n[l]);if(a){i=a(n);for(var p=0;p<i.length;p++)o.call(n,i[p])&&(c[i[p]]=n[i[p]])}}return c}}}]);